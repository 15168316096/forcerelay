# IBC Connection Handshake (ICS3) English Spec

> Reviews are welcome.


## L1. Problem statement / outside view

Suppose there are two chains (e.g., distributed ledgers) that execute independently of each other.
What should be an abstraction for representing a path of communication between the two?
We use a __connection__ abstraction to represent this path of communication [[see ICS 003 spec](#references)].

The IBC connection handshake protocol, at the highest level of abstraction, enables two chains to establish, i.e., __open__, a connection with each other.
Once open, connections cannot be closed, so a closing handshake does not exist.
Whenever we speak of connection handshake, we implicitly mean the __opening__ handshake.
Throughout the rest of this document, we will often use the abbreviation "ICS3" to stand for __connection handshake__ problem (or protocol, depending on the context).

A connection involves the two __parties__ (the respective chains) involved in the communication, as well as a __relayer__ which handles message transmission between the chains.
The relayer carries a central responsibility in handshaking and maintaining a connection (described below).
That is, a connection handshake is essentially a three-party protocol: two chains, plus a relayer.

#### Sequential problem statement

###### Definitions
A chain comprises three elements that are relevant for connections:

- a __module__, or the "connection handshake module": this is a process (running as a component of the chain) which implements the ICS3 protocol;
- the __store__ of the chain, alternatively called the "consensus state" or just "state";
- a __client__: a processes running on that chain, which represents a window onto the store of the other chain.

We give concrete names, Alice and Bob, to the chains involved in our problem, to simplify description.
The diagram below sketches the system model of the connection handshake problem.
Note that the _client_ on Alice points to the _store_ on Bob; vice versa is true for the _client_ on Bob (but there is no corresponding arrow to keep the figure cleaner).
Alice and Bob have no direct medium for communicating with each other, so a relayer process sits between the two chains and enables their communication (more details on this will follow).



```
                     IBC Connection Handshake
                        High-level Model
        Alice                               Bob
     +-----------+                     +-----------+
     |   Chain   |     +---------+     |   Chain   |
     |           |<--->| Relayer |<--->|           |
     | +-------+ |     +---------+     | +-------+ |
     | |Module | |                     | |Module | |
     | +-------+ |                     | +-------+ |
     | +-------+ |                     | +-------+ |
     | | Store | |                    -->| Store | |
     | +-------+ |            -------/ | +-------+ |
     |+---------+|   --------/         |+---------+|
     || Client  |---/                  || Client  ||
     |+---------+|                     |+---------+|
     +-----------+                     +-----------+
```

Beside chain-specific components, there are also relayer-specific abstractions, which will be discussed at L2 and L3.

###### Problem statement and guarantees
A connection handshake allows, briefly, that the modules on two chains agree on a consistent view of their state (i.e., their store), and each module allocates a new connection associated with this state.

We identify two basic (high-level) requirements that a connection handshake should guarantee:

- **[ICS3-Seq-1-Agreement]** If Alice finishes a handshake by establishing a new connection `c1` with Bob, and Bob finishes the handshake obtaining the connection `c2`, then `c1 == c2`.
In other words, if a connection handshake finishes, the two parties have a consistent view of this connection (one end of the connection at Alice, and the other end at Bob).

- **[ICS3-Seq-2-Termination]** Eventually, the modules should both finish the handshake, establishing a connection.

Requirement **[ICS3-Seq-1-Agreement]** represents the basic safety guarantee, while **[ICS3-Seq-2-Termination]** is the basic liveness guarantee we would like to have.


## L2. Protocol specification / protocol view

### 2.1 System model specification

#### System model

A **chain** is a deterministic state machine.
Each chain may be replicated, i.e., consisting of a replicated state machine (RSM), or it may be a standalone process.
As a side note, there are certain requirements a chain must satisfy in practice(e.g., see [[ICS 024](#references)]); at this level of specification, however, we model each chain as consisting of those three components we described earlier: module, store, and a client.

In ICS3, __actors__ represent entities that may trigger this protocol and provide exterior feedback to the protocol. To quote from IBC terminology:

> An actor, or a user (used interchangeably), is an entity interacting with the IBC protocol. An actor can be a human end-user, a module or smart contract running on a blockchain, or an off-chain relayer process capable of signing transactions. [[IBC terminology](#references)]

###### Communication assumptions

A relayer intermediates communication between Alice and Bob.
We model communication as a shared mutable state.
Each chain exposes an API comprising read, write, as well as a queue (FIFO) capabilities.
So there are two parts to the communication API:

  1. a read/write store (holding the entire state of the chain)
      - each module can write to this store, using function `setConnection`;
      - and external processes -- in our case, any relayer -- can read from the store via a function `getConnection`;

  2. a queue of datagrams (or messages)
      - each module can `pop` datagrams stored in this queue;
      - external processes (relayers) can `push` to this queue.

We describe the API in the code snippet below.
Connection handshake modules implement this interface.
Note that we use the modifiers 'private' and 'public' to denote which API function can be invoked by external processes (e.g., relayer) and which functions are private to the module implementing this interface.
The data types (`Identifier` and `ConnectionEnd`) are defined below.

```golang
type CommunicationLayer interface {
    // Write a new value (a connection) to the local store, indexed by the
    // identifier of the connection on the local party.
    private setConnection(i Identifier, e ConnectionEnd)

    // Relayer invokes this to `read` from a chains' local store.
    public getConnection(i Identifier) -> ConnectionEnd
    
    // Relayer invokes this to append a datagram into a chain's 
    // local store.
    public push("outstandingDatagrams", g Datagram)

    // A module consumes elements from its local store 
    // "outstandingDatagrams".
    private pop("outstandingDatagrams") -> Datagram
    // The typical use case is that for each datagram, this module invokes the 
    // corresponding handler, e.g., ConnTryHandler.
}
```

Preconditions:
  - the datagram `g` as well as Identifier `i` and Connection `e` (respectively for `push`, `setConnection` and `getConnection`) are non-null;

Postconditions:
  - for `setConnection`: the local store on the module implementing this function stores at position `i` the value `e`;
  - for `push`: the `outstandingDatagrams` queue will append the Datagram `g`

Error conditions: 
  - `getConnection` may fail (returning `null`) if no `ConnectionEnd` exists for the input parameter `i`;
  - before invoking the function `setConnection`, the caller should make sure that the client in the `Identifier` field was created;


Properties of the communication layer:

- **[ICS3-CommAssumption-1-RWIntegrity]** If some connection `e` is returned from `getConnection(i)` then the `setConnection(i, e)` was previously invoked.

- **[ICS3-CommAssumption-2-QueueIntegrity]** If some module `d` returns a datagram `g` from `Pop("outstandingDatagrams")`, then a process previously invoked `Push("outstandingDatagrams", g)`.

- **[ICS3-CommAssumption-3-QueueNoLoss]** If some process invokes `Push("outstandingDatagrams", g)`, then eventually a `Pop` operation will return `g`.


Refinement remarks (relation to L3):
  - The `push` function is a more abstract version of `submitDatagram` [ICS018](#references).
  - The `setConnection` function is a more abstract version of the functionality accomplished by `provableStore.set` and `addConnectionToClient` [ICS 003](#references).
  - The `getConnection` function is the analogy to `getConnection` [ICS 018](#references).
  - Missing link to L3: what is the mechanism that implements the `pop` functionality at the implementation/L3 level (hint: it's in the SDK, the layer sitting between the consensus module and IBC Handler).


###### Fault assumptions
The chains Alice and Bob (and their module, local store, and client, respectively) may be subject to arbitrary (Byzantine) faults.
The properties we define below are guaranteed to hold iff both Alice and Bob behave correctly, i.e., do not deviate from any protocol we describe below.
Beside these two parties, the system comprises an arbitrary number of other parties, any of which may be Byzantine; these other chains may, for instance, try to impersonate Alice or Bob or attack them in some way.
The termination property of the ICS3 protocol depends on the existence of at least one correct relayer.
Additionally, there may be an arbitrary number of relayers that can communicate (i.e., [read/push](#communication-assumptions)) to Alice and Bob and are subject to Byzantine faults.


###### Additional remarks on the system model
We explicitly overlook here two assumptions of synchrony that may be necessary for achieving liveness of **other** protocols, but they are not necessary within the ICS3 protocol.
These assumptions are: (i) partial synchrony is necessary for achieving liveness of a chain if that chain is implemented using a deterministic consensus protocol (e.g., Tendermint Core); (ii) synchrony is necessary for guaranteeing message delivery in any connection-oriented protocol such as TCP, which is most likely the underlying network transport layer (implementing the `CommunicationLayer` between modules and relayers).


#### Properties

###### Preliminary abstractions
We introduce several abstractions that are relevant at this point:

1. A `ConnectionParty` is a data type encapsulating the details that identify a party.

```golang
type ConnectionParty interface {
  connectionIdentifier    Identifier
  clientIdentifier        Identifier
  prefix                  Prefix
}
```

2. A `ConnectionState` captures the state of a connection, and may have one of the following values.

```typescript
enum ConnectionState {
  INIT,
  TRYOPEN,
  OPEN,
}
```

3. A `ConnectionEnd` is a data type that captures all the details of a connection at a party.
This includes a _remote_ and a _local_ field, so that the local party is the one storing this object, and the remote party is the other one.
One of the goals of the connection handshake protocol is to allocate an object of this type at each of Alice and Bob.

```golang
type ConnectionEnd interface {
  state                             ConnectionState
  remoteParty                       ConnectionParty
  localParty                        ConnectionParty
  version                           []String
}
```


4. A `ConnProof` and `ClientProof` are two data types that abstracts over the details of a cryptographic proof that any module can create, and another module can verify.
Intuitively, a proof is helpful for some module to guarantee that it is in a certain state.
We are concerned with connection proofs (`ConnProof` type) and client proofs (`ClientProof`) here.

```golang
type ConnProof struct {
  connectionEnd ConnectionEnd // The connection that the remote party claims to havie.
}
```

```golang
type ClientProof struct {
  height uint64 // The height which the client (on remote party) claims having.
}
```


Further, we also define the interface of a `Store` on each chain, which maintains the state of the chain.
This is a straightforward key/value store.


```golang
type Store interface {
  // Returns the value stored at key `k`, possibly returning null if no value
  // was previously set at key `k`.
  get(k) -> []byte

  // Sets the value at position `k` to be `v`, overwritting if this key is
  // already present; always returns null (success).
  set(k String, v []byte) -> null
}
```

Importantly, queries to this store can be made from the outside (e.g., by a relayer).
More precisely, `setConnection` and `getConnection` are wrappers over `set` and `get`; this shared memory interface is more accurately described in the communication assumptions [above](#communication-assumptions).

We now restate the connection handshake problem in a slightly more precise (or lower level) formulation:
_A connection handshake enables two modules (each sitting on a chain) to agree on a consistent view of their chain state, to verify each other's state, and to allocate a new connection._


###### Guarantees
We refine the safety guarantee **[ICS3-Seq-1-Agreement]** (defined in the [sequential problem statement](#sequential-problem-statement)) by splitting this into four complementary safety properties:

- **[ICS3-Proto-1-ConnectionValidity]**
If any correct module establishes a `ConnectionEnd` `e`, then `e` is _valid_; validity is defined by an application-level predicate.

- **[ICS3-Proto-2-ConnectionUniqueness]**
If a module establishes a `ConnectionEnd` `e`, no handshake has previously finished for `e`; uniqueness is defined by an application-level predicate.

- **[ICS3-Proto-3-ConnectionIntegrity]**
If any two modules establish a connection `e`, then either one module or the other or both modules proposed `e`.

- **[ICS3-Proto-4-StateConsistency]**
If any two modules establish a connection, then the client in the first module is consistent with the state of the second module.

The liveness property, equivalent to [ICS3-Seq-2-Termination] the livenes property in the sequential specification above:

- **[ICS3-Proto-5-Termination]**
If the two parties involved in a connection handshake are correct, then the connection handshake eventually terminates.
Specifically, termination implies that each module allocates in the local state a new `ConnectionEnd` object with `state` field set to `OPEN`.


_Remarks_:

- We could collapse validity and uniqueness under a single property, since they are both defined through an application predicate.
This is not desirable, however, because in the implementation the two properties serve different purposes, so we should keep them separated.

- Note that property **[ICS3-Proto-4-StateConsistency]** works both ways.
This property applies to _any two modules_ (there is no predefined "first" or "second" module in a connection).


### 2.2 Protocol

The ICS3 protocol comprises four steps, summarized below.

1. An actor invokes the `ConnInitHandler` handler at the ICS3 module in one of the chains; this sets off the connection handshake protocol.
In our example, we will use Alice as the party to execute `ConnInitHandler`.
Once Alice does so, this handler marks the connection on her end as initialized (i.e., `INIT`).

2. This comprises two sub-steps:
    - 2.a. Upon observing that Alice has executed `ConnInitHandler` (meaning that her state contains a connection that is `INIT`), the relayer constructs a datagram of type `ConnOpenTry` and pushes this at Bob's module;
    - 2.b. Bob handles this datagram via the `ConnTryHandler` handler. Once this handler finishes,  the connection on his end is marked as `TRYOPEN`.

3. This comprises two sub-steps:
    - 3.a. Upon observing that Bob has finished executing `ConnTryHandler` (i.e., his state contains a `TRYOPEN` connection), the relayer constructs a datagram of type `ConnOpenAck` and pushes this at Alice's module;
    - 3.b. Alice handles this datagram by invoking the `ConnAckHandler` handler. Once this handler finishes, Alice considers her `ConnectionEnd` in state `OPEN`.

4. This comprises two sub-steps:
    - 4.a. When the relayer observes that Alice finished handling the `ConnOpenAck` datagram (and consequently the connection is open on her side), the relayer constructs a `ConnOpenConfirm` datagram and pushes it on Bob's side.
    - 4.b. Finally, Bob's module processes the `ConnOpenConfirm` datagram through an eponymous handler, which sets the connection state to `OPEN` for him and thereby marks the termination of the ICS3 protocol.

The diagram below sketches these fours steps of handshake protocol.

```
               The four steps comprising
             IBC Connection Handshake Protocol

     +-----------+                         +-----------+
     |  Module   |                         |   Module  |
     |   Alice   |                         |    Bob    |
     |         step 1                      |           |
     |     ConnInitHandler                    |           |
     |  ►INIT    |                         |           |
     |           |<-2.a--Relayer-----2.a-->|           |
     |           |                 |       |           |
     |           |                  \-> step 2.b       |
     |           |                     ConnTryHandler  |
     |           |                         | ►TRYOPEN  |
     |           <--3.a------Relayer--3.a->|           |
     |           |        |                |           |
     |      step 3.b <---/                 |           |
     |     ConnAckHandler                  |           |
     |  ►OPEN    |                         |           |
     |           |<-4.a---Relayer----4.a-->|           |
     |           |                 |       |           |
     |           |                  \-> step 4.b       |
     |           |              ConnConfirmHandler     |
     |           |                         | ►OPEN     |
     +-----------+                         +-----------+
```


#### Protocol handler signatures

We first present the signatures of the four protocol handlers; the connection handshake module at each party implements and exposes these handlers.

```golang
func ConnInitHandler(local ConnectionParty,
                  remote ConnectionParty)

func ConnTryHandler(local ConnectionParty,
                 remote ConnectionParty,
                 remoteVersions []String,
                 proofsHeight uint64,
                 remoteConnectionProof ConnProof,
                 remoteClientProof ClientProof)

func ConnAckHandler(local ConnectionParty,
                 remoteVersion String,
                 proofsHeight uint64,
                 remoteConnectionProof ConnProof,
                 remoteClientProof ClientProof)

func ConnConfirmHandler(local ConnectionParty,
                     proofsHeight uint64,
                     remoteConnectionProof ConnProof)
```

#### Main Protocol Handlers

We first define the four protocol handlers, and then describe the datagrams.
Finally, we discuss some helper functions.

###### ConnInitHandler

This is step 1.

```golang
func ConnInitHandler(local ConnectionParty, remote ConnectionParty)
{
  // Create local end of the connection.
  connectionEnd.state = 'INIT'
  connectionEnd.local = local
  connectionEnd.remote = remote
  connectionEnd.version = getCompatibleVersions()

  // Validity check. (Explained below in helper functions).
  abortTransactionUnless(validate(connectionEnd))

  // Uniqueness check. (Explained below in helper functions).
  abortTransactionUnless(unique(connectionEnd))

  // Now save this connectionE in the local store.
  // Since this connectionEnd is in state INIT, the relayer will continue with
  // next steps of the connection handshake protocol.
  setConnection(local.connectionIdentifier, connectionEnd)
}
```

Preconditions:
  - the connection (obtained from the input `local` and `remote` arguments) is valid and unique

Postconditions:
  - the module executing this handler stores a `ConnectionEnd` (matching with the input arguments `local` and `remote`) in state `INIT`
  - function produces no output; may abort if preconditions not met

Implementation remarks:
  - to ensure termination of the ICS3 protocol, this handler must execute at least once (either on one of the chains or both)


###### ConnTryHandler

This is step 2.b.

```golang
func ConnTryHandler(local ConnectionParty,
                    remote ConnectionParty,
                    remoteVersions []String,
                    proofsHeight uint64,
                    remoteConnectionProof ConnProof,
                    remoteClientProof ClientProof)
{
  // Create local end of the connection.
  connectionEnd.state = TRYOPEN
  connectionEnd.local = local
  connectionEnd.remote = remote
  connectionEnd.version = pickVersion(remoteVersions)

  // Validity check.
  abortTransactionUnless(validate(connectionEnd))

  // Uniqueness check.
  // This should check that either there is no connection of if there is on
  // it is in INIT state.
  abortTransactionUnless(unique(connectionEnd))
  current = getConnection(local.connectionIdentifier)
  if current != nil {
    abortTransactionUnless(current.state = 'INIT')
  }

  // Proofs verification.
  // The client on the local party should already be updated with the height
  // which the two proofs target, proofsHeight.
  abortTransactionUnless(
    localClientHasConsensusHeight(proofsHeight))
  // `verifyProofs` does a cryptographic (syntactic) verification of proofs.
  // See definition below in helper functions.
  abortTransactionUnless(
    verifyProofs(proofsHeight, remoteConnectionProof, 
      remoteClientProof, connectionEnd))

  // Semantic verification of both proofs.
  // 1. connection proof must reflect a connection that is in 'INIT' state.
  abortTransactionUnless(
      remoteConnectionProof.connectionEnd.state = 'INIT')
  // 2. client proof: the client on remote party should be consistent with
  // the state of local party.
  abortTransactionUnless(
    remoteClientProof.height <= getLocalConsensusHeight)

  // Handler is done: store the connectionEnd and let the relayer handle
  // the next step.
  setConnection(local.connectionIdentifier, connectionEnd)
}
```


Preconditions:
  - the connection (obtained from inputs `local` and `remote`) is valid and unique (see definition below for the `unique` function)
  - the module running this handler supports at least one of the versions supplied in the input list `remoteVersions`
  - the two proofs `remoteConnectionProof` and `remoteClientProof` are syntactically and semantically correct; this is necessary in connection to properties [ICS3-Proto-3-ConnectionIntegrity] and [ICS3-Proto-4-StateConsistency]

Postconditions:
  - the module executing this handler stores a `ConnectionEnd` (matching with the arguments `local` and `remote`) in state `TRYOPEN`
  - no output; may abort if preconditions not met

Implementation remarks:
  - the `validate` check should also check the field `connectionEnd.version`.


###### ConnAckHandler

Step 3.b.

```golang
func ConnAckHandler(local ConnectionParty,
                    remoteVersion String,
                    proofsHeight uint64,
                    remoteConnectionProof ConnProof,
                    remoteClientProof ClientProof)
{
  // Search the details of this connection in local store.
  connectionEnd = get(local.connectionIdentifier)

  // This verification helps guarantee integrity:
  // [ICS3-Proto-3-ConnectionIntegrity].
  abortTransactionUnless(connectionEnd != nil
                         && connectionEnd.local == local)

  // Another integrity check: should not overwrite a connection that is
  // already `OPEN`.
  abortTransactionUnless(connectionEnd.state == INIT
                         || connectionEnd.state == TRYOPEN)

  // Verification of proofs.
  abortTransactionUnless(
    localClientHasConsensusHeight(proofsHeight))
  // Synactic proof checks. See definition below in helper functions.
  abortTransactionUnless(
    verifyProofs(proofsHeight, remoteConnectionProof, 
      remoteClientProof, connectionEnd))
  // Semantic verification of both proofs.
  abortTransactionUnless(
      remoteConnectionProof.connectionEnd.state = 'OPEN')
  abortTransactionUnless(
    remoteClientProof.height <= getLocalConsensusHeight)

  // Another integrity check: the handler should not open a connection
  // unless it is for a version that the local party agrees with.
  abortTransactionUnless(compatibleVersion(remoteVersion))

  // Termination (partial -- only at this end)
  connectionEnd.state = OPEN
  connectionEnd.version = remoteVersion

  // Update the connectionEnd in local state.
  setConnection(local.connectionIdentifier, connectionEnd)
}
```


Preconditions:
  - The module executing this handler already has a `ConnectionEnd` stored locally, matching the `local` argument, and in state `INIT` or `TRYOPEN`.
  - The supplied argument `remoteVersion` is supported (compatible)
  - the two proofs `remoteConnectionProof` and `remoteClientProof` are syntactically and semantically correct; for guaranteeing properties [ICS3-Proto-3-ConnectionIntegrity] and [ICS3-Proto-4-StateConsistency]

Postconditions:
  - the module executing this handler stores a `ConnectionEnd` (matching with the arguments `local`) in state `OPEN`
  - no output

Implementation remarks:
  - The `abortTransactionUnless(getCompatibleVersions())` check is very low-level. The `validate()` predicate should verify the `version` field, so it would be cleaner to invoke that predicate.


###### ConnConfirmHandler

Step 4.b.

```golang
func ConnConfirmHandler(local ConnectionParty,
                        proofsHeight uint64,
                        remoteConnectionProof ConnProof)
{
  // Search the details of this connection in the local store.
  connectionEnd = get(local.connectionIdentifier)

  // Helps guarantee integrity [ICS3-Proto-3-ConnectionIntegrity].
  abortTransactionUnless(connectionEnd != nil
                         && connectionEnd.local == local)

  // Integrity check: the handler should not overwrite a connection that is
  // already OPEN. And should not be working with a connection that is 
  // INIT. The only acceptable state is TRYOPEN.
  abortTransactionUnless(connectionEnd.state == TRYOPEN)

  // Verification of proofs. 
  abortTransactionUnless(
    localClientHasConsensusHeight(proofsHeight))
  // Syntactic checks. See definition below in helper functions.
  abortTransactionUnless(
    verifyProofs(proofsHeight, remoteConnectionProof, 
      nil, connectionEnd))
  // Semantic check: the other party is expected to be 'OPEN'.
  abortTransactionUnless(
      remoteConnectionProof.connectionEnd.state = 'OPEN')

  // Termination.
  connectionEnd.state = OPEN
  setConnection(local.connectionIdentifier, connectionEnd)
}
```

Preconditions:
  - the input proof `remoteConnectionProof` is syntactically and semantically correct; for guaranteeing property [ICS3-Proto-3-ConnectionIntegrity]
  - The module executing this handler has a `ConnectionEnd` stored locally, (matching the input argument `local`) and in state `TRYOPEN`.

Postconditions:
  - the module executing this handler stores a `ConnectionEnd` (matching with the input argument `local`) in state `OPEN`
  - no output; may abort if preconditions not met

Implementation remarks:
  - (none)


##### Datagrams

A correct relayer can push the following datagrams at a chain.
Upon popping a datagram of a certain type, e.g., `ConnOpenConfirm`, a correct chain handles the datagram by invoking an eponymous handler.

```golang
type ConnOpenInit struct {
  local   ConnectionParty
  remote  ConnectionParty
}

type ConnOpenTry struct {
  local                 ConnectionParty
  remote                ConnectionParty
  remoteVersions        []String
  remoteConnectionProof Proof
  proofsHeight          uint64
  remoteClientProof     Proof
}

type ConnOpenAck struct {
  local                 ConnectionParty
  remoteVersion         String
  remoteConnectionProof Proof
  proofsHeight          uint64
  remoteClientProof     Proof
}

type ConnOpenConfirm struct {
  local                 ConnectionParty
  proofsHeight          uint64
  remoteConnectionProof Proof
}
```

Notice that the fields in each datagram match with the corresponding protocol handler signature.

#### Helper functions & application-level predicates

###### `verifyProofs`

```golang
func verifyProofs(proofsHeight uint64,
                  remoteConnectionProof Proof, 
                  remoteClientProof Proof,
                  connectionEnd ConnectionEnd)
  // Two syntactic check: for each proof, verify that it is authentic.
  // This return either true (success) or false (failure).
  // It is also acceptable that this function triggers an abort (e.g., due to
  // malformed input).
  if ~verifyProofAuthenticity(proofsHeight, remoteConnectionProof, connectionEnd) {
    return false
  }
  if remoteClientProof != nil {
    // This return either true (success) or false (failure). Aborting is also
    // acceptable.
    if ~verifyProofAuthenticity(proofsHeight, remoteClientProof, connectionEnd) {
      return false
    }
  }
  return true
```

Preconditions:
  - all three input parameters have to be well-formed and non-nil.

Postconditions:
  - returns true upon success, false if any verification failed.
  - if any of the preconditions are violated, the function may abort.
  - no side-effects.


###### `unique(ConnectionEnd c)`
This function takes as input a `ConnectionEnd` `c` and returns true if the input value `c` is unique.
Concretely, this verifies that there is no value stored in the local store at key `c.local.connectionIdentifier`, OR there is a value stored at this key and this value is identical with the supplied argument `c`.

###### `validate(ConnectionEnd c)` 
This checks that the object `connectionEnd.local.connectionIdentifier` is valid.
Similar in functionality with `validateConnectionIdentifier` from [ICS 003]; additionally, this function should also validate the `version` field.

###### `pickVersion(counterpartyVersions)` 
This is identical with the one in [ICS 003](#references).

###### `getCompatibleVersions()`
This is identical with the one in [ICS 003](#references).


###### `constructConnectionProof()` and `constructClientProof()`

These functions are not shown here, but they are part of the relayer logic so we mention them nonetheless.
These are more abstract variants of the `proof()` method that a connection implements (see [ICS 018](#references) in particular).

###### `verifyProofAuthenticity`

This function is analogous to `verifyConnectionState` and `verifyClientConsensusState` of the [ICS 003](#references).


### Open questions:

- Standard cryptographic assumptions (collision-resistant hash functions, public-key signatures). We should mention these once we have more details about the implementation.

- How to capture aborts or incorrect termination? See [issue raised by Anca](https://github.com/informalsystems/ibc-rs/pull/42#discussion_r397077901). Is this necessary? To inform this discussion, more implementation detials are neeeded.

- **Verification of the unbonding period** in `ConnTryHandler`. See [ICS/#403](https://github.com/cosmos/ics/issues/403).



## References

- [ICS 003] Interchain Standards [ICS 003 Connection Semantics](https://github.com/cosmos/ics/tree/master/spec/ics-003-connection-semantics).
- [ICS 024] Interchain Standards [ICS 024 Host Requirements](https://github.com/cosmos/ics/tree/master/spec/ics-024-host-requirements).
- [ICS 018] Interchain Standards [ICS 024 Host Requirements](https://github.com/cosmos/ics/tree/master/spec/ics-018-relayer-algorithms).
- [IBC 1] Terminology. Interchain Standards [IBC 1 Terminology](https://github.com/cosmos/ics/blob/master/ibc/1_IBC_TERMINOLOGY.md#actor).
