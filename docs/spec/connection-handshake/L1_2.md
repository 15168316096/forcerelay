# IBC Connection Handshake (ICS3) English Spec

> Reviews are welcome.


## L1. Problem statement / outside view

Suppose there are two chains (e.g., distributed ledgers) that execute independently of each other.
What should be an abstraction for representing a path of communication between the two?
We use a __connection__ abstraction to represent this path of communication [[see ICS 003 spec](#references)].

The IBC connection handshake protocol, at the highest level of abstraction, enables two chains to establish, i.e., __open__, a connection with each other.
Once open, connections cannot be closed, so a closing handshake does not exist.
Whenever we speak of connection handshake, we implicitly mean the __opening__ handshake.
Throughout the rest of this document, we will often use the abbreviation "ICS3" to stand for __connection handshake__ problem (or protocol, depending on the context).

A connection involves the two __parties__ (the respective chains) involved in the communication, as well as a __relayer__ which handles message transmission between the chains.
The relayer carries a central responsibility in handshaking and maintaining a connection (described below).
That is, a connection handshake is essentially a three-party protocol: two chains, plus a relayer.

#### Sequential problem statement

###### Definitions
A chain comprises three elements that are relevant for connections:

- a __module__, or the "connection handshake module": this is a process (running as a component of the chain) which implements the ICS3 protocol;
- the __store__ of the chain, alternatively called the "consensus state" or just "state";
- a __client__: a processes running on that chain, which represents a window onto the store of the other chain.

We give concrete names, Alice and Bob, to the chains involved in our problem, to simplify description.
The diagram below sketches the system model of the connection handshake problem.
Note that the _client_ on Alice points to the _store_ on Bob; vice versa is true for the _client_ on Bob (but there is no corresponding arrow to keep the figure cleaner).
Alice and Bob have no direct medium for communicating with each other, so a relayer process sits between the two chains and enables their communication (more details on this will follow).



```
                     IBC Connection Handshake
                        High-level Model
        Alice                               Bob
     +-----------+                     +-----------+
     |   Chain   |     +---------+     |   Chain   |
     |           |<--->| Relayer |<--->|           |
     | +-------+ |     +---------+     | +-------+ |
     | |Module | |                     | |Module | |
     | +-------+ |                     | +-------+ |
     | +-------+ |                     | +-------+ |
     | | Store | |                    -->| Store | |
     | +-------+ |            -------/ | +-------+ |
     |+---------+|   --------/         |+---------+|
     || Client  |---/                  || Client  ||
     |+---------+|                     |+---------+|
     +-----------+                     +-----------+
```

Beside chain-specific components, there are also relayer-specific abstractions, which will be discussed at L2 and L3.

###### Problem statement and guarantees
A connection handshake allows, briefly, that the modules on two chains agree on a consistent view of their state (i.e., their store), and each module allocates a new connection associated with this state.

We identify two basic (high-level) requirements that a connection handshake should guarantee:

- **[ICS3-Seq-1-Agreement]** If Alice finishes a handshake by establishing a new connection `c1` with Bob, and Bob finishes the handshake obtaining the connection `c2`, then `c1 == c2`.
In other words, if a connection handshake finishes, the two parties have a consistent view of this connection (one end of the connection at Alice, and the other end at Bob).

- **[ICS3-Seq-2-Termination]** Eventually, the modules should both finish the handshake, establishing a connection.

Requirement **[ICS3-Seq-1-Agreement]** represents the basic safety guarantee, while **[ICS3-Seq-2-Termination]** is the basic liveness guarantee we would like to have.


## L2. Protocol specification / protocol view

### 2.1 System model specification

#### System model

A **chain** is a deterministic state machine.
Each chain may be replicated, i.e., consisting of a replicated state machine (RSM), or it may be a standalone process.
As a side note, there are certain requirements a chain must satisfy in practice(e.g., see [[ICS 024](#references)]); at this level of specification, however, we model each chain as consisting of those three components we described earlier: module, store, and a client.

In ICS3, __actors__ represent entities that may trigger this protocol and provide exterior feedback to the protocol. To quote from IBC terminology:

> An actor, or a user (used interchangeably), is an entity interacting with the IBC protocol. An actor can be a human end-user, a module or smart contract running on a blockchain, or an off-chain relayer process capable of signing transactions. [[IBC terminology](#references)]

###### Communication assumptions

A relayer intermediates communication between Alice and Bob.
We model communication as a shared mutable state.
Each chain exposes an API comprising read, write, as well as a queue (FIFO) capabilities.
So there are two parts to the communication API:

  1. a read/write store (holding the entire state of the chain)
      - each module can write to this store, using function `setConnection`;
      - and external processes -- in our case, any relayer -- can read from the store via a function `getConnection`;

  2. a queue of datagrams (or messages)
      - each module can `pop` datagrams stored in this queue;
      - external processes (relayers) can `push` to this queue.

We describe the API in the code snippet below.
Connection handshake modules implement this interface.
Note that we use the modifiers 'private' and 'public' to denote which API function can be invoked by external processes (e.g., relayer) and which functions are private to the module implementing this interface.
The data types (`Identifier` and `ConnectionEnd`) are defined below.

```golang
type CommunicationLayer interface {
    // Write a new value (a connection) to the local store, indexed by the
    // identifier of the connection on the local party.
    private setConnection(i Identifier, e ConnectionEnd)

    // Relayer invokes this to `read` from a chains' local store.
    public getConnection(i Identifier) // returns a `ConnectionEnd`
    
    // Relayer invokes this to append a datagram into a chain's 
    // local store.
    public push("outstandingDatagrams", g Datagram)

    // A module consumes elements from its local store 
    // "outstandingDatagrams".
    private pop("outstandingDatagrams") // returns a Datagram
    // The typical use case is that for each datagram, this module invokes the 
    // corresponding handler, e.g., ConnOpenTry.
}
```

Preconditions:
  - the datagram `g` as well as Identifier `i` and Connection `e` (respectively for `push`, `setConnection` and `getConnection`) are non-null;

Postconditions:
  - for `setConnection`: the local store on the module implementing this function stores at position `i` the value `e`;
  - for `push`: the `outstandingDatagrams` queue will append the Datagram `g`

Error condition: none

Properties of the communication layer:

- **[ICS3-CommAssumption-1-RWIntegrity]** If some connection `e` is returned from `getConnection(i)` then the `setConnection(i, e)` was previously invoked.

- **[ICS3-CommAssumption-2-QueueIntegrity]** If some module `d` returns a datagram `g` from `Pop("outstandingDatagrams")`, then a process previously invoked `Push("outstandingDatagrams", g)`.

Neither of the functions in this interface are blocking.

In addition to these four function, we also define a helper method to allow a relayer to obtain a list of all connections that a module stored.

```golang
    // A relayer can invoke this to `read` all connections stored by a chain.
    public getAllConnections() // returns a `ConnectionEnd[]`
```

Refinement remarks (relation to L3):
  - The `push` function is a higher-level version of `submitDatagram` [ICS018](#references).
  - The `setConnection` function is a higher-level version of functionality accomplished by `provableStore.set` and `addConnectionToClient` [ICS 003](#references).
  - The `getConnection` and `getAllConnections` functions are higher-level versions of `getConnectionsUsingClient` and `getConnection` [ICS 018](#references).
  - Missing link to L3: what is the mechanism that implements the `pop` functionality at the implementation/L3 level (hint: it's in the SDK, the layer sitting between the consensus module and IBC Handler).


###### Fault assumptions
The chains Alice and Bob (and their module, local store, and client, respectively) may be subject to arbitrary (Byzantine) faults.
The properties we define below are guaranteed to hold iff both Alice and Bob behave correctly, i.e., do not deviate from any protocol we describe below.
Beside these two parties, the system comprises an arbitrary number of other parties, any of which may be Byzantine; these other chains may, for instance, try to impersonate Alice or Bob or attack them in some way.
The termination property of the ICS3 protocol depends on the existence of at least one correct relayer.
Additionally, there may be an arbitrary number of relayers that can communicate (i.e., [read/push](#communication-assumptions)) to Alice and Bob and are subject to Byzantine faults.


###### Additional remarks on the system model
We explicitly overlook here two assumptions of synchrony that may be necessary for achieving liveness of **other** protocols, but they are not necessary within the ICS3 protocol.
These assumptions are: (i) partial synchrony is necessary for achieving liveness of a chain if that chain is implemented using a deterministic consensus protocol (e.g., Tendermint Core); (ii) synchrony is necessary for guaranteeing message delivery in any connection-oriented protocol such as TCP, which is most likely the underlying network transport layer (implementing the `CommunicationLayer` between modules and relayers).


#### Properties

###### Preliminary abstractions
We introduce several abstractions that are relevant at this point:

1. A `ConnectionParty` is a data type encapsulating the details that identify a party.

```golang
type ConnectionParty interface {
  connectionIdentifier    Identifier
  clientIdentifier        Identifier
  prefix                  Prefix
}
```

2. A `ConnectionState` captures the state of a connection, and may have one of the following values.

```typescript
enum ConnectionState {
  INIT,
  TRYOPEN,
  OPEN,
}
```

3. A `ConnectionEnd` is a data type that captures all the details of a connection at a party.
One of the goals of the connection handshake protocol is to allocate an object of this type at each of Alice and Bob.

```golang
type ConnectionEnd interface {
  state                             ConnectionState
  remoteParty                       ConnectionParty
  localParty                        ConnectionParty
  version                           []String
}
```

Note that the definition of `ConnectionEnd` includes a _remote_ and a _local_ field; in a specific `ConnectionEnd` object, the local party is the one storing this object, and the remote party is the other one.


4. A `Proof` is a data type that abstracts over the details of a cryptographic proof that any module can create, and another module can verify.
Intuitively, a proof is helpful for some module to guarantee that it is in a certain state.

```golang
type Proof struct {
  content     CommitmentProof // the actual proof
  height      uint64
}

```

Further, we also define the interface of a `Store` on each chain, which maintains the state of the chain.
This is a straightforward key/value store.


```golang
type Store interface {
  // Returns the value stored at key `k`, possibly returning null if no value
  // was previously set at key `k`.
  get(k) -> byte[]

  // Sets the value at position `k` to be `v`, overwritting if this key is
  // already present; always returns null (success).
  set(k string, v byte[]) -> null
}
```

Importantly, this store is shared with the relayer.
More precisely, `setConnection` and `getConnection` are wrappers over `set` and `get`.
This shared memory interface is more accurately described in the communication assumptions [above](#communication-assumptions).

We now restate the connection handshake problem in a slightly more precise (or lower level) formulation:
_A connection handshake enables two modules (each sitting on a chain) to agree on a consistent view of their chain state, to verify each other's state, and to allocate a new connection._


###### Guarantees
We refine the safety guarantee **[ICS3-Seq-1-Agreement]** (defined in the [sequential problem statement](#sequential-problem-statement)) by splitting this into four complementary safety properties:

- **[ICS3-Proto-1-ConnectionValidity]**
If any correct module establishes a `ConnectionEnd` `e`, then `e` is _valid_; validity is defined by an application-level predicate.

- **[ICS3-Proto-2-ConnectionUniqueness]**
If a module establishes a `ConnectionEnd` `e`, no handshake has previously finished for `e`; uniqueness is defined by an application-level predicate.

- **[ICS3-Proto-3-ConnectionIntegrity]**
If any two modules establish a connection `e`, then either one module or the other or both modules proposed `e`.

- **[ICS3-Proto-4-StateConsistency]**
If any two modules establish a connection, then the client in the first module is consistent with the state of the second module.

The liveness property, equivalent to [ICS3-Seq-2-Termination] the livenes property in the sequential specification above:

- **[ICS3-Proto-5-Termination]**
If the two parties involved in a connection handshake are correct, then the connection handshake eventually terminates.
Specifically, termination implies that each module allocates in the local state a new `ConnectionEnd` object with `state` field set to `OPEN`.


_Remarks_:

- We could collapse validity and uniqueness under a single property, since they are both defined through an application predicate.
This is not desirable, however, because in the implementation the two properties serve different purposes, so we should keep them separated.

- Note that property **[ICS3-Proto-4-StateConsistency]** works both ways.
This property applies to _any two modules_ (there is no predefined "first" or "second" module in a connection).


### 2.2 Protocol

The ICS3 protocol comprises four steps, summarized below.

1. An actor invokes the `ConnOpenInit` handler at the ICS3 module in one of the chains; this sets off the connection handshake protocol.
In our example, we will use Alice as the party to execute `ConnOpenInit`.
Once Alice executes this handler, she marks the connection on her end as initialized (i.e., `INIT`).

2. This comprises two sub-steps:
    - 2.a. Upon observing that Alice has executed `ConnOpenInit` (meaning that her state contains a connection that is `INIT`), the relayer constructs a datagram of type `ConnOpenTry` and pushes this at Bob's module;
    - 2.b. Bob handles this datagram via the `ConnOpenTry` handler. Once this handler finishes, Bob marks the connection on his end as `TRYOPEN`.

3. This comprises two sub-steps:
    - 3.a. Upon observing that Bob has finished executing `ConnOpenTry` (i.e., his state contains a `TRYOPEN` connection), the relayer constructs a datagram of type `ConnOpenAck` and pushes this at Alice's module;
    - 3.b. Alice handles this datagram by invoking the `ConnOpenAck` handler. Once this handler finishes, Alice considers her `ConnectionEnd` in state `OPEN`.

4. This comprises two sub-steps:
    - 4.a. When the relayer observes that Alice finished handling the `ConnOpenAck` datagram (and consequently the connection is open on her side), the relayer constructs a `ConnOpenConfirm` datagram and pushes it on Bob's side.
    - 4.b. Finally, Bob's module processes the `ConnOpenConfirm` datagram through an eponymous handler, which sets the connection state to `OPEN` for him and thereby marks the termination of the ICS3 protocol.

The diagram below sketches these fours steps of handshake protocol.

```
               The four steps comprising
             IBC Connection Handshake Protocol

     +-----------+                         +-----------+
     |  Module   |                         |   Module  |
     |   Alice   |                         |    Bob    |
     |         step 1                      |           |
     |     ConnOpenInit                    |           |
     |  ►INIT    |                         |           |
     |           |<-2.a--Relayer-----2.a-->|           |
     |           |                 |       |           |
     |           |                  \-> step 2.b       |
     |           |                       ConnOpenTry   |
     |           |                         | ►TRYOPEN  |
     |           <--3.a------Relayer--3.a->|           |
     |           |        |                |           |
     |      step 3.b <---/                 |           |
     |     ConnOpenAck                     |           |
     |  ►OPEN    |                         |           |
     |           |<-4.a---Relayer----4.a-->|           |
     |           |                 |       |           |
     |           |                  \-> step 4.b       |
     |           |               ConnOpenConfirm       |
     |           |                         | ►OPEN     |
     +-----------+                         +-----------+
```


#### Protocol handler signatures

We first present the signatures of the four protocol handlers; the connection handshake module at each party implements and exposes these handlers.

```golang
func ConnOpenInit(local ConnectionParty,
                  remote ConnectionParty)

func ConnOpenTry(local ConnectionParty,
                 remote ConnectionParty,
                 remoteVersions string[],
                 remoteConnectionProof Proof,
                 remoteClientProof Proof)

func ConnOpenAck(local ConnectionParty,
                 remoteVersion string,
                 remoteStateProof Proof,
                 remoteClientProof Proof)

func ConnOpenConfirm(local ConnectionParty,
                     remoteStateProof Proof)
```

#### Main Protocol Handlers

We first define the four protocol handlers, and then describe the relayer functionality & datagrams.
Finally, we describe helper functions.

###### ConnOpenInit

This is step 1.

```golang
func ConnOpenInit(local ConnectionParty, remote ConnectionParty)
{
  // Create our own end of the connection.
  connectionEnd.state = INIT
  connectionEnd.local = local
  connectionEnd.remote = remote
  connectionEnd.version = getCompatibleVersions()

  // Validity check. (Explained below in helper functions).
  abortTransactionUnless(validate(connectionEnd))

  // Uniqueness check. (Explained below in helper functions).
  abortTransactionUnless(unique(connectionEnd))

  // Now we save this connectionE in our local store.
  // Since this connectionEnd is in state INIT, the relayer will continue with
  // next steps of the connection handshake protocol.
  setConnection(local.connectionIdentifier, connectionEnd)
}
```

Preconditions:
  - the connection (obtained from the input `local` and `remote` arguments) is valid and unique

Postconditions:
  - the module executing this handler stores a `ConnectionEnd` (matching with the input arguments `local` and `remote`) in state `INIT`
  - function produces no output; may abort if preconditions not met

Implementation remarks:
  - to ensure termination of the ICS3 protocol, this handler must execute at least once (either on one of the chains or both)


###### ConnOpenTry

This is step 2.b.

```golang
func ConnOpenTry(local ConnectionParty,
                 remote ConnectionParty,
                 remoteVersions []String,
                 remoteStateProof Proof,
                 remoteClientProof Proof)
{
  // Create our end of the connection.
  connectionEnd.state = TRYOPEN
  connectionEnd.local = local
  connectionEnd.remote = remote
  connectionEnd.version = pickVersion(remoteVersions)

  // Validity check.
  abortTransactionUnless(validate(connectionEnd))

  // Uniqueness check.
  abortTransactionUnless(unique(connectionEnd))

  // `verifyProofs` does a complete verification of proofs.
  // See definition below in helper functions.
  abortTransactionUnless(
    verifyProofs(remoteStateProof, remoteClientProof, connectionEnd))

  // Handler is done: store the connectionEnd and let the relayer handle
  // the next step.
  setConnection(local.connectionIdentifier, connectionEnd)
}
```

Preconditions:
  - the connection (obtained from inputs `local` and `remote`) is valid and unique
  - the module running this handler supports at least one of the versions supplied in the input list `remoteVersions`
  - the two proofs `remoteStateProof` and `remoteClientProof` are syntactically and semantically correct; this is necessary in connection to properties [ICS3-Proto-3-ConnectionIntegrity] and [ICS3-Proto-4-StateConsistency]

Postconditions:
  - the module executing this handler stores a `ConnectionEnd` (matching with the arguments `local` and `remote`) in state `TRYOPEN`
  - no output; may abort if preconditions not met

Implementation remarks:
  - the `validate` check should also check the field `connectionEnd.version`.


###### ConnOpenAck

Step 3.b.

```golang
func ConnOpenAck(local ConnectionParty,
                 remoteVersion string,
                 remoteStateProof Proof,
                 remoteClientProof Proof)
{
  // Search the details of this connection in our local store.
  connectionEnd = get(local.connectionIdentifier)

  // This verification helps guarantee integrity:
  // [ICS3-Proto-3-ConnectionIntegrity].
  abortTransactionUnless(connectionEnd != nil
                         && connectionEnd.local == local)

  // Another integrity check: we should not overwrite a connection that is
  // already `OPEN`.
  abortTransactionUnless(connectionEnd.state == INIT
                         || connectionEnd.state == TRYOPEN)

  // Verification of proofs. See definition below in helper functions.
  abortTransactionUnless(
    verifyProofs(remoteStateProof, remoteClientProof, connectionEnd))

  // Another integrity check: We should not open a connection unless it is for
  // a version that we agree with.
  abortTransactionUnless(compatibleVersion(remoteVersion))

  // Termination (partial -- only at this end)
  connectionEnd.state = OPEN

  // Update the connectionEnd in our state.
  setConnection(local.connectionIdentifier, connectionEnd)
}
```


Preconditions:
  - The module executing this handler already has a `ConnectionEnd` stored locally, matching the `local` argument, and in state `INIT` or `TRYOPEN`.
  - The supplied argument `remoteVersion` is supported (compatible)
  - the two proofs `remoteStateProof` and `remoteClientProof` are syntactically and semantically correct; for guaranteeing properties [ICS3-Proto-3-ConnectionIntegrity] and [ICS3-Proto-4-StateConsistency]

Postconditions:
  - the module executing this handler stores a `ConnectionEnd` (matching with the arguments `local`) in state `OPEN`
  - no output

Implementation remarks:
  - The `abortTransactionUnless(getCompatibleVersions())` check is very low-level. The `valid()` predicate should verify the `version` field, so it would be cleaner to invoke that predicate.


###### ConnOpenConfirm

Step 4.b.

```golang
func ConnOpenConfirm(local ConnectionParty,
                     remoteStateProof Proof)
{
  // Search the details of this connection in our local store.
  connectionEnd = get(local.connectionIdentifier)

  // Helps guarantee integrity [ICS3-Proto-3-ConnectionIntegrity].
  abortTransactionUnless(connectionEnd != nil
                         && connectionEnd.local == local)

  // Integrity check: we should not overwrite a connection that is
  // already OPEN. And we should not be working with a connection that is 
  // INIT. The only acceptable state is TRYOPEN.
  abortTransactionUnless(connectionEnd.state == TRYOPEN)

  // Verification of proofs. See definition below in helper functions.
  abortTransactionUnless(
    verifyProofs(remoteStateProof, nil, connectionEnd))

  // Termination.
  connectionEnd.state = OPEN
  setConnection(local.connectionIdentifier, connectionEnd)
}
```

Preconditions:
  - the input proof `remoteStateProof` is syntactically and semantically correct; for guaranteeing property [ICS3-Proto-3-ConnectionIntegrity]
  - The module executing this handler has a `ConnectionEnd` stored locally, (matching the input argument `local`) and in state `TRYOPEN`.

Postconditions:
  - the module executing this handler stores a `ConnectionEnd` (matching with the input argument `local`) in state `OPEN`
  - no output; may abort if preconditions not met

Implementation remarks:
  - (none)


##### Datagrams

A correct relayer can pushe the following datagrams at a chain.
Upon popping a datagram of a certain type, e.g., `ConnOpenConfirm`, a correct chain handles the datagram by invoking an eponymous handler.

```golang
type ConnOpenInit struct {
  local   ConnectionParty
  remote  ConnectionParty
}

type ConnOpenTry struct {
  local               ConnectionParty
  remote              ConnectionParty
  remoteVersions      []String
  remoteStateProof    Proof
  remoteClientProof   Proof
}

type ConnOpenAck struct {
  local               ConnectionParty
  remoteVersion       String
  remoteStateProof    Proof
  remoteClientProof   Proof
}

type ConnOpenConfirm struct {
  local             ConnectionParty
  remoteStateProof  Proof
}
```

Notice that the fields in each datagram match with the corresponding protocol handler signature.

##### Relayer Logic

A correct relayer periodically scans a pair of chains and, if the chains are in a specific state (e.g., a connection is `INIT` on one of the chains and inexistent in the other chain), then the relayer performs the necessary steps in the ICS3 protocol (e.g., construct the necessary `ConnOpenTry` datagram and pushes this datagram to the second chain).


###### Step 2.a:

```golang
// Assume `cAlice` is a connection on chain Alice.
if (cAlice.state == INIT) {
  // Handshake started at Alice (step 1 done because the connection is INIT).

  // Fetch the connection end from the other chain (Bob)
  cBob := chains[Bob].getConnection(cAlice.remote.connectionIdentifier)
  
  // We will do step 2.a, by pushing a `ConnOpenTry` to Bob.
  if (cBob == null || cBob.state == INIT) {
    // Construct the appropriate datagram.
    d := ConnOpenTry{
      cAlice.remote,                // Bob's end (a ConnectionParty object)
      cAlice.local,                 // Alice's end
      cAlice.version,               // Alice's proposed version
      constructStateProof(cAlice),
      constructClientProof(cAlice)}

    // Push the datagram to Bob's module
    chains[Bob].push(d)
  }
}
```

###### Step 3.a:

```golang
// Assume `cBob` is a connection on chain Bob.
if (cBob.state == TRYOPEN) {
  // Fetch the matching connection end from Alice's side
  cAlice := chains[Alice].getConnection(cBob.remote.connectionIdentifier)
  
  // Handshake ConnOpenTry (step 2) done at Bob.
  // We will push a `ConnOpenAck` to Alice. This is step 3.a.
  if (cAlice.state == INIT || cAlice.state == TRYOPEN) {
    // Construct the appropriate datagram.
    d := ConnOpenAck{
      cBob.remote,                // Alice's party details
      cBob.version,               // Bob's proposed version
      constructStateProof(cBob),
      constructClientProof(cBob)}

    // Push the datagram to Bob's module
    chains[Alice].push(d)
  }
}
```

###### Step 4.a:

```golang
// Assume `cAlice` is a connection on chain Alice.
if (cAlice.state == OPEN) {
  // Fetch the matching connection end from Alice's side
  cBob := chains[Bob].getConnection(cAlice.remote.connectionIdentifier)
  
  // Handshake ConnOpenAck (step 3) done at Alice.
  // We will push a `ConnOpenConfirm` to Bob. This is step 4.a.
  if (cBob.state == TRYOPEN) {
    // Construct the appropriate datagram.
    d := ConnOpenConfirm{
      cBob.local,                 // Bob's party details
      constructStateProof(cAlice)}

    // Push the datagram to Bob's module
    chains[Bob].push(d)
  }
}
```

#### Helper functions & application-level predicates

###### `verifyProofs`

```golang
func verifyProofs(remoteStateProof Proof, 
                  remoteClientProof Proof,
                  connectionEnd ConnectionEnd)
  // Two syntactic check: for each proof, verify that it is authentic.
  // This return either true (success) or false (failure).
  // It is also acceptable that this function triggers an abort (e.g., due to
  // malformed input).
  if ~verifyProofAuthenticity(remoteStateProof, connectionEnd) {
    return false
  }
  if remoteClientProof != nil {
    // This return either true (success) or false (failure). Aborting is also
    // acceptable.
    if ~verifyProofAuthenticity(remoteClientProof, connectionEnd) {
      return false
    }
  }

  // Semantic checks of both proofs: interpret proof content and verify that
  // they make sense with respect to connection handshake protocol and our
  // state.
  // 1. Verify that the remote party has performed the 'INIT' step for this
  // specific connectionEnd. This helps guarantee the property
  // [ICS3-Proto-3-ConnectionIntegrity].
  // May trigger an abort if the verification fails. Usually returns true
  // or false.
  t = verifyRemoteState(remoteStateProof, ConnectionEnd)
  if t == false {
    return false
  }
  // 2. Verify that the client on the remote party is consistent with my state.
  // It seems that remoteStateProof is necessary for this step. This also
  // checks, among others, that remoteClientProof.height <= getCurrentHeight()
  // cf. [ICS 003].
  if remoteClientProof != nil {
    // May trigger an abort if the verification fails. Usually returns true
    // or false.
    if ~verifyRemoteClient(remoteClientProof, getLocalConsensusState(remoteClientProof.height) {
      return false
    }
  }
  return true
```

Preconditions:
  - `remoteClientProof` may be nil
  - `remoteStateProof` and `connectionEnd` have to be well-formed and non-nil

Postconditions:
  - returns true upon success, false if any verification failed.
  - if any of the preconditions are violated, the function may abort.
  - no side-effects.


###### `unique(ConnectionEnd c)`
This function takes as input a `ConnectionEnd` `c` and returns true if the input value `c` is unique.
Concretely, this verifies that there is no value stored in the local store at key `c.local.connectionIdentifier`, OR there is a value stored at this key and this value is identical with the supplied argument `c`.

###### `validate(ConnectionEnd c)` 
This checks that the object `connectionEnd.local.connectionIdentifier` is valid.
Similar in functionality with `validateConnectionIdentifier` from [ICS 003]; additionally, this function should also validate the `version` field.

###### `pickVersion(counterpartyVersions)` 
This is identical with the one in [ICS 003](#references).

###### `getCompatibleVersions()`
This is identical with the one in [ICS 003](#references).


###### `constructStateProof()` and `constructClientProof()`

These are higher-level variants of the `proof()` method that a connection implements (see [ICS 018](#references) in particular).

###### `verifyProofAuthenticity`, `verifyRemoteState`, `verifyRemoteClient`

These three functions are higher-level versions of `verifyConnectionState` and `verifyClientConsensusState`.


### Open questions:

- Standard cryptographic assumptions (collision-resistant hash functions, public-key signatures). We should mention these once we have more details about the implementation.

- How to capture aborts or incorrect termination? See [issue raised by Anca](https://github.com/informalsystems/ibc-rs/pull/42#discussion_r397077901). Is this necessary? To inform this discussion, more implementation detials are neeeded.

- **Verification of the unbonding period** in `ConnOpenTry`. See [ICS/#403](https://github.com/cosmos/ics/issues/403).

## L3: Implementation

At this level, we _decapsulate_ some of the abstractions we introduced at L2.
The goal is to strip away some of fields that may not be needed, and obtain function handlers that are identical with the ones specified in [ICS 003](#references).

The following list is of modification is non-exhaustive:

- Whenever we would use a `ConnectionParty` object, for instance, we would replace that object with the actual fields of the `ConnectionParty` that are needed (stripping off those fields that are unnecessary).
For example, instead of sending two `ConnectionParty` objects around, we send only the relevant fields.

Instead of:
```golang
func ConnOpenTry(a ConnectionParty, b ConnectionParty) { ...
```

in the actual code, we write:
```golang
func ConnOpenTry(
  desiredIdentifier: Identifier,
  counterpartyConnectionIdentifier: Identifier,
  counterpartyPrefix: CommitmentPrefix,
  counterpartyClientIdentifier: Identifier,
  clientIdentifier: Identifier,
  ...) {
```

- Whenever we use a `Proof` object, open up this abstraction and send both fields (i.e., `content` and `height`) as individual objects.

In other words, at this level of the spec, the protocol handlers become identical with those in [ICS 003](#references).
This decapsulation step essentially removes any abstractions that might be encumbering at the implementaiton level.


## References

- [ICS 003] Interchain Standards [ICS 003 Connection Semantics](https://github.com/cosmos/ics/tree/master/spec/ics-003-connection-semantics).
- [ICS 024] Interchain Standards [ICS 024 Host Requirements](https://github.com/cosmos/ics/tree/master/spec/ics-024-host-requirements).
- [ICS 018] Interchain Standards [ICS 024 Host Requirements](https://github.com/cosmos/ics/tree/master/spec/ics-018-relayer-algorithms).
- [IBC 1] Terminology. Interchain Standards [IBC 1 Terminology](https://github.com/cosmos/ics/blob/master/ibc/1_IBC_TERMINOLOGY.md#actor).
