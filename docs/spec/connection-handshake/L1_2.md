# IBC Connection Handshake Spec

> Work in progress.
> This is NOT ready for review.

<!-- > All the content until section [2.2 Protocol] is stable and ready for review. -->

<!-- > Reviews are welcome. -->

<!-- The hypothesis that this document is testing is that it can inform an implementation beneficially, i.e., help better design the abstraction and architecture of an implementation of connection handshake protocol. piush-->


## L1. Problem statement / outside view

Suppose there are two chains (e.g., distributed ledgers) that execute independently of each other.
What should be an abstraction for representing a path of communication between the two?
We use a _connection_ abstraction to represent this path of communication.

The IBC connection handshake protocol, at the highest level of abstraction, enables two chains to establish, i.e., open, a connection with each other [[ICS 003](#references)].
Once open, connections cannot be closed, so a closing handshake does not exist; whenever we speak of handshake, we implicitly mean the opening handshake.
Throughout the rest of this document, we will often use the abbreviation "CH" to stand for _connection handshake_ problem (or protocol, depending on the context).

A connection involves the two _parties_ involved in the communication (the respective chains), as well as a _relayer_ which handles message transmission between the parties.
The relayer carries a central responsibility in handshaking and maintaining a connection (described below).
That is, a connection handshake is essentially a three-party protocol: a party called Alice, a party called Bob, and a relayer `y`.


#### Sequential problem statement

###### Definitions
When we speak of a party, we identify three relevant elements:

- a _module_: or the connection handshake module; this is the process which actually implements the CH protocol;
- the _local state_ of the party, sometimes called the _consensus_ state;
- a _client_ residing on that party, which is a window onto the state of the other party.

We give concrete names, Alice and Bob, to the parties involved in our problem.
The diagram below sketches the system model of the connection handshake problem.
Note that the _client_ on Alice points to the _state_ on Bob; vice versa is true for the _client_ on Bob (but there is no corresponding arrow to keep the figure cleaner).

```
                     IBC Connection Handshake
                         High-level Model
     +-----------+                       +-----------+
     |   Chain   |                       |   Chain   |
     |   Alice   |                       |    Bob    |
     | +-------+ |                       | +-------+ |
     | |Module | |                       | |Module | |
     | +-------+ |                       | +-------+ |
     | +-------+ |                       | +-------+ |
     | | State | |                    ---->| State | |
     | +-------+ |            -------/   | +-------+ |
     |+---------+|   --------/           |+---------+|
     || Client  |---/                    || Client  ||
     |+---------+|                       |+---------+|
     +-----------+                       +-----------+
```

###### Problem statement and guarantees
A connection handshake allows, briefly, that the _modules_ on two _chains_ agree on a consistent view of their _state_, and each module allocates a new connection associated with this state.
We identify two abstract (high-level) requirements that a connection handshake should guarantee:

- **[CH/Seq/1/Agreement]** If Alice finishes a handshake by establishing a new connection `ci` with Bob, and Bob finishes the handshake obtaining the connection `cr`, then `ci == cr`.
In other words, if a connection handshake finishes, the two parties have a consistent view of this connection (one at Alice and the other at Bob).

- **[CH/Seq/2/Termination]** Eventually, the modules should both finish the handshake, establishing a connection.

Requirement **[CH/Seq/1/Agreement]** represents the basic safety guarantee, while **[CH/Seq/2/Termination]** is the basic liveness guarantee we would like to have.


## L2. Protocol specification / protocol view

### 2.1 System model specification

#### System model

A **chain** is a deterministic state machine.
Each chain may be replicated, i.e., consisting of a replicated state machine (RSM), or it may be a standalone process.
In practice, there are certain requirements which each chain must satisfy (e.g., see [[ICS 024](#references)]).
At this level of specification, however, we model each chain as consisting of a module, state, and a client.

When we speak of a party or a chain, we typically mean the _module_ executing on that party.

On top of each chain, one or multiple **applications** may be running (e.g., payment system or token exchanges, with their associated smart contracts).
Applications are the high-level entities that require the connection abstraction to be able to build cross-chain logic.
It is not an application that triggers the connection handshake protocol, however; in the IBC terminology, it is an **actor** that invokes the CH protocol and provides the necessary input for executing this protocol (we give more details on the invocation & input below).
An actor may be a relayer or a smart contract, for instance [[IBC terminology](#references)].

At a high-level, the handshake protocol consists of modules on chain Alice and on chain Bob exchanging -- with the aid of a relayed -- a few messages called **datagrams**.
Each datagram has a well-defined syntax which we describe later.
[[2.2 Protocol](#22-protocol).]

We define a **connection** as a bidirectional or unidirectional path of communication that applications on the two chains use to exchange **packets**.
Packets are payloads from the point of view of a connection; they contain arbitrary application-level data, and their content is opaque to a connection; suffice to say that applications generate and consume packets.

To summarize, the purpose of a connection is to enable chains Alice and Bob -- as well as applications running on top of these chains -- to coordinate updates to their state.


###### Communication assumptions

A relayer serves as a communication medium between Alice and Bob.
We model communication as a shared mutable state, and the API offers read, write, as well as a queue capabilities.
We describe the API in the code snippet below.

There are two parts to the communication API:

  1. a read/write store which each module can access by writing, using function `setConnection`, and external processes -- in our case, any relayer -- can read from via a function `getConnection`; and 

  2. a queue of incoming datagrams that each module can `pop`, and external processes can `push` to.


```golang
// Connection handshake modules implement this interface.
// Note that we use the modifiers 'private' and 'public' to denote which API
// function can be invoked by external processes (e.g., relayer) and which
// functions are private to the module implementing this interface.
type CommunicationLayer interface {
    
    // Write a new value (a connection) to the local store, indexed by the
    // identifier of the connection on the local party.
    private setConnection(i Identifier, e ConnectionEnd)

    // Relayer invokes this to `read` from a chains' local store.
    public getConnection(i Identifier) // returns a `ConnectionEnd`
    
    // Relayer invokes this to append a datagram into a chain's 
    // local store.
    public push("outstandingDatagrams", g Datagram)

    // A module eventually consumes elements from its local store 
    // "outstandingDatagrams".
    private pop("outstandingDatagrams") // returns a Datagram
    // The typical use case is that for each datagram, this module invokes the 
    // corresponding handler, e.g., ConnOpenTry.
}
```


- **Expected precondition:**
  - the datagram `g` as well as Identifier `i` and Connection `e` (respectively for `push`, `setConnection` and `getConnection`) are non-null;
- **Expected postcondition:**
  - for `setConnection`: the local store on the module implementing this function stores at position `i` the value `e`;
  - for `push`: the `outstandingDatagrams` queue at the module enqueue the Datagram `g`
- **Error condition:** none

- **Properties of the communication layer:**

    - **[CH/CommAssumption/1/RWIntegrity]** If some process returns a connection `e` from `getConnection(i)` for some module, then the module previously `setConnection(i, e)`.

    - **[CH/CommAssumption/2/QueueIntegrity]** If some module `d` returns a datagram `g` from `Pop("outstandingDatagrams")`, then a process previously invoked `Push("outstandingDatagrams", g)`.

Neither of the functions in this interface are blocking.

In addition to these four function, we also define a helper method to allow a relayer to obtain a list of all connections that a module stored.

```golang
    // A relayer can invoke this to `read` all connections stored by a chain.
    public getAllConnections() // returns a `ConnectionEnd[]`
```

Implementatio remarks:
  - The `push` function is a higher-level version of `submitDatagram` [ICS018](#references).
  - The `setConnection` function is a higher-level version of functionality accomplished by `provableStore.set` and `addConnectionToClient` [ICS 003](#references).
  - The `getConnection` and `getAllConnections` functions are higher-level versions of functions `getConnectionsUsingClient` and `getConnection` [ICS 018](#references).
  - TODO: document here the mechanism that implements the `pop` functionality at the implementation level (hint: it's in the SDK).


###### Fault assumptions
The chains Alice and Bob (and their modules, local store, and client, respectively) may be subject to arbitrary (Byzantine) faults.
The properties we define below are guaranteed to hold iff both Alice and Bob behave correctly, i.e., do not deviate from any protocol we describe below.
Beside these two parties, the system comprises an arbitrary number of other parties, any of which may be Byzantine; these other chains may, for instance, try to impersonate Alice or Bob.
The termination property of the CH protocol depends on the existence of at least one correct relayer.
Additionally, there may be an arbitrary number of relayers that can communicate (i.e., [read/push](#communication-assumptions)) to Alice and Bob and are subject to Byzantine faults.


###### Additional remarks on the system model
We explicitly overlook here two assumptions of synchrony that may be necessary for achieving liveness of **other** protocols, but they are not necessary within the CH protocol.
These assumptions are: (i) partial synchrony is necessary for achieving liveness of a chain if that chain is implemented using a deterministic consensus protocol (e.g., Tendermint Core); (ii) synchrony is necessary for guaranteeing message delivery in any connection-oriented protocol such as TCP, which is most likely the underlying network transport layer running between each module and the relayer.


#### Properties

###### Preliminary Abstractions
We introduce several abstractions that are relevant at this point:

1. A `ConnectionParty` is a data type encapsulating the details that identify a party.

```golang
type ConnectionParty interface {
  connectionIdentifier    Identifier
  clientIdentifier        Identifier
  prefix                  Prefix
}
```

2. A `ConnectionState` captures the state of a connection, and may have one of the following values.

```typescript
enum ConnectionState {
  INIT,
  TRYOPEN,
  OPEN,
}
```

3. A `ConnectionEnd` is a data type that captures all the details of a connection at a party.
One of the goals of the connection handshake protocol is to allocate an object of this type at each of Alice and Bob.

```golang
type ConnectionEnd interface {
  state                             ConnectionState
  remoteParty                       ConnectionParty
  localParty                        ConnectionParty
  version                           string | []string
}
```

Note that the definition of `ConnectionEnd` includes a _remote_ and a _local_ field; in a specific `ConnectionEnd` object, the local party is the one storing this object, and the remote party is the other one.


4. A `Proof` is a data type that abstracts over the details of a cryptographic proof that any module can create, and another module can verify.
Intuitively, a proof is helpful for some module to guarantee that it is in a certain state.

```golang
type Proof struct {
  content     CommitmentProof // the actual proof
  height      uint64
}

```

Further, we also define the interface of a `Store` on each chain, which maintains the state of the chain.
This is a straightforward key/value store.


```golang
type Store interface {
  // Returns the value stored at key `k`, possibly returning null if no value
  // was previously set at key `k`.
  get(k) -> byte[]

  // Sets the value at position `k` to be `v`, overwritting if this key is
  // already present; always returns null (success).
  set(k string, v byte[]) -> null
}
```

Importantly, this store is shared with the relayer.
More precisely, `setConnection` and `getConnection` are wrappers over `set` and `get`.
This shared memory interface is more accurately described in the communication assumptions [above](#communication-assumptions).

We now restate the connection handshake problem in a slightly more precise (or lower level) formulation:
_A connection handshake enables modules on two chains to agree on a consistent view of their chain state, to verify each other's state, and to allocate a new connection._


###### Guarantees
We refine the safety guarantee **[CH/Seq/1/Agreement]** (defined in the [sequential problem statement](#sequential-problem-statement)) by splitting this into four complementary safety properties:

- **[CH/Proto/1/ConnectionValidity]**
If a module establishes a connection with `ConnectionEnd` `e`, then `e` is _valid_; validity is defined by an application-level predicate.

- **[CH/Proto/2/ConnectionUniqueness]**
If a module establishes a `ConnectionEnd` `e`, no handshake has previously finished for `e`; uniqueness is defined by an application-level predicate.

- **[CH/Proto/3/ConnectionIntegrity]**
If any two modules establish a connection `e`, then either one module or the other or both modules proposed `e`.

- **[CH/Proto/4/StateConsistency]**
If any two modules establish a connection, then the client in the first module is consistent with the state of the second module.

- **[CH/Proto/5/Termination]**
If the two parties involved in a connection handshake are correct, then the connection handshake eventually terminates.
Specifically, termination implies that each module allocates in the local state a new `ConnectionEnd` object with `state` field set to `OPEN`.


_Remarks_:

- We could collapse validity and uniqueness under a single property, since they are both defined through an application predicate.
This is not desirable, however, because in the implementation the two properties serve different purposes, so we should keep them separated.

- Note that property **[CH/Proto/4/StateConsistency]** works both ways.
This property applies to _any two modules_ (there is no predefined "first" or "second" module in a connection).


### 2.2 Protocol

The CH protocol comprises four steps, summarized below.

1. An actor invokes the `ConnOpenInit` handler at the CH module in one of the chains; this sets off the connection handshake protocol.
In our example, we will use Alice as the party to execute `ConnOpenInit`.
Once Alice executes this handler, she marks the connection on her end as initialized (i.e., `INIT`).

2. This comprises two sub-steps:
    - 2.a. Upon observing that Alice has executed `ConnOpenInit` (meaning that her state contains a connection that is `INIT`), the relayer constructs a datagram of type `ConnOpenTry` and pushes this at Bob's module;
    - 2.b. Bob handles this datagram via the `ConnOpenTry` handler. Once this handler finishes, Bob marks the connection on his end as `TRYOPEN`.

3. This comprises two sub-steps:
    - 3.a. Upon observing that Bob has finished executing `ConnOpenTry` (i.e., his state contains a `TRYOPEN` connection), the relayer constructs a datagram of type `ConnOpenAck` and pushes this at Alice's module;
    - 3.b. Alice handles this datagram by invoking the `ConnOpenAck` handler. Once this handler finishes, Alice considers her Connection `OPEN`.

4. This comprises two sub-steps:
    - 4.a. When the relayer observes that Alice finished handling the `ConnOpenAck` datagram (and consequently the connection is open on her side), the relayer constructs a `ConnOpenConfirm` datagram and pushes it on Bob's side.
    - 4.b. Finally, Bob's module processes the `ConnOpenConfirm` datagram through an eponymous handler, which tags the connection `OPEN` for him and thereby marks the termination of the CH protocol.

The diagram below sketches these fours steps of handshake protocol.

```
               The four steps comprising
             IBC Connection Handshake Protocol

     +-----------+                         +-----------+
     |  Module   |                         |   Module  |
     |   Alice   |                         |    Bob    |
     |         step 1                      |           |
     |     ConnOpenInit                    |           |
     |  ►INIT    |                         |           |
     |           |<-2.a--Relayer-----2.a-->|           |
     |           |                 |       |           |
     |           |                  \-> step 2.b       |
     |           |                       ConnOpenTry   |
     |           |                         | ►TRYOPEN  |
     |           <--3.a------Relayer--3.a->|           |
     |           |        |                |           |
     |      step 3.b <---/                 |           |
     |     ConnOpenAck                     |           |
     |  ►OPEN    |                         |           |
     |           |<-4.a---Relayer----4.a-->|           |
     |           |                 |       |           |
     |           |                  \-> step 4.b       |
     |           |               ConnOpenConfirm       |
     |           |                         | ►OPEN     |
     +-----------+                         +-----------+
```


#### Protocol handler signatures

We first present the signatures of the four protocol handlers; the connection handshake module at each party implements and exposes these handlers.

```golang
func ConnOpenInit(local ConnectionParty,
                  remote ConnectionParty)

func ConnOpenTry(local ConnectionParty,
                 remote ConnectionParty,
                 remoteVersions string[],
                 remoteStateProof Proof,
                 remoteClientProof Proof)

func ConnOpenAck(local ConnectionParty,
                 remoteVersion string,
                 remoteStateProof Proof,
                 remoteClientProof Proof)

func ConnOpenConfirm(local ConnectionParty,
                     remoteStateProof Proof)
```

#### Main Protocol Handlers

We first define the four protocol handlers, and then describe the relayer functionality & datagrams.
Finally, we describe helper functions.

###### ConnOpenInit

```golang
func ConnOpenInit(local ConnectionParty, remote ConnectionParty)
{
  // Create our own end of the connection.
  connectionEnd.state = INIT
  connectionEnd.local = local
  connectionEnd.remote = remote
  connectionEnd.version = getCompatibleVersions()

  // Validity check. (Explained below in helper functions).
  abortTransactionUnless(validate(connectionEnd))

  // Uniqueness check. (Explained below in helper functions).
  abortTransactionUnless(unique(connectionEnd))

  // Now we save this connectionE in our local store.
  // Since this connectionEnd is in state INIT, the relayer will continue with
  // next steps of the connection handshake protocol.
  setConnection(local.connectionIdentifier, connectionEnd)
}
```

Preconditions:
  - the connection (obtained from the input `local` and `remote` arguments) is valid and unique

Postconditions:
  - the module executing this handler stores a `ConnectionEnd` (matching with the input arguments `local` and `remote`) in state `INIT`
  - the module executing this handler creates a new `ConnectionEnd` in state `INIT`
  - function produces no output; may abort if preconditions not met

Implementation remarks:
  - to ensure termination of the CH protocol, this handler must execute at either one of the chains or both


###### ConnOpenTry

```golang
func ConnOpenTry(local ConnectionParty,
                 remote ConnectionParty,
                 remoteVersions string[],
                 remoteStateProof Proof,
                 remoteClientProof Proof)
{
  // Create our end of the connection.
  connectionEnd.state = TRYOPEN
  connectionEnd.local = local
  connectionEnd.remote = remote
  connectionEnd.version = pickVersion(remoteVersion)

  // Validity check.
  abortTransactionUnless(validate(connectionEnd))

  // Uniqueness check.
  abortTransactionUnless(unique(connectionEnd))

  // This does a complete verification of everything related to proofs.
  // See definition below in helper functions.
  abortTransactionUnless(
    verifyProofs(remoteStateProof, remoteClientProof, connectionEnd))

  // Handler is done: store the connectionEnd and let the relayer handle
  // the next step.
  setConnection(local.connectionIdentifier, connectionEnd)
}
```

Preconditions:
  - the connection (obtained from inputs `local` and `remote`) is valid and unique
  - the module running this handler supports at least one of the versions supplied in the input list `remoteVersions`
  - the two proofs `remoteStateProof` and `remoteClientProof` are syntactically and semantically correct; for guaranteeing properties [CH/Proto/3/ConnectionIntegrity] and [CH/Proto/4/StateConsistency]

Postconditions:
  - the module executing this handler stores a `ConnectionEnd` (matching with the arguments `local` and `remote`) in state `TRYOPEN`
  - no output; may abort if preconditions not met

Implementation remarks:
  - the validity check should also check the field `connectionEnd.version`.


###### ConnOpenAck

```golang
func ConnOpenAck(local ConnectionParty,
                 remoteVersion string,
                 remoteStateProof Proof,
                 remoteClientProof Proof)
{
  // Search the details of this connection in our local store.
  connectionEnd = get(local.connectionIdentifier)

  // This verification helps guarantee integrity:
  // [CH/Proto/3/ConnectionIntegrity].
  abortTransactionUnless(connectionEnd != nil
                         && connectionEnd.local == local)

  // Another integrity check: we should not overwrite a connection that is
  // already open. At first glance, it seems that we can actually drop this
  // verification without any harm. Note we already checked above (implicitly) 
  // that the connectionEnd is in state INIT or TRYOPEN. Still, not 100% we 
  // can drop this check -- never hurts to be cautious.
  abortTransactionUnless(connectionEnd.state == INIT
                         || connectionEnd.state == TRYOPEN)

  // Verification of proofs. See definition below in helper functions.
  abortTransactionUnless(
    verifyProofs(remoteStateProof, remoteClientProof, connectionEnd))

  // Another integrity check: We should not open a connection unless it is for
  // a version that we agree with.
  abortTransactionUnless(getCompatibleVersions().indexOf(remoteVersion) !== -1)

  // Termination (partial -- only at this end)
  connectionEnd.state = OPEN

  // Update the connectionEnd in our state.
  setConnection(local.connectionIdentifier, connectionEnd)
}
```


Preconditions:
  - The module executing this handler already has a `ConnectionEnd` stored locally, matching the `local` argument, and in state `INIT` or `TRYOPEN`.
  - The supplied argument `remoteVersion` is supported (compatible)
  - the two proofs `remoteStateProof` and `remoteClientProof` are syntactically and semantically correct; for guaranteeing properties [CH/Proto/3/ConnectionIntegrity] and [CH/Proto/4/StateConsistency]

Postconditions:
  - the module executing this handler stores a `ConnectionEnd` (matching with the arguments `local`) in state `OPEN`
  - no output

Implementation remarks:
  - The `abortTransactionUnless(getCompatibleVersions())` check is very low-level; we can make this cleaner by integrating it into the `valid()` predicate, and invoking that predicate.


###### ConnOpenConfirm

```golang
func ConnOpenConfirm(local ConnectionParty,
                     remoteStateProof Proof)
{
  // Search the details of this connection in our local store.
  connectionEnd = get(local.connectionIdentifier)

  // Helps guarantee integrity [CH/Proto/3/ConnectionIntegrity].
  abortTransactionUnless(connectionEnd != nil
                         && connectionEnd.local == local)

  // Integrity check: we should not overwrite a connection that is
  // already OPEN. And we should not be working with a connection that is 
  // INIT. The only acceptable state is TRYOPEN.
  abortTransactionUnless(connectionEnd.state == TRYOPEN)

  // Verification of proofs. See definition below in helper functions.
  abortTransactionUnless(
    verifyProofs(remoteStateProof, nil, connectionEnd))

  // Termination.
  connectionEnd.state = OPEN
  setConnection(local.connectionIdentifier, connectionEnd)
}
```

Preconditions:
  - the input proof `remoteStateProof` is syntactically and semantically correct; for guaranteeing property [CH/Proto/3/ConnectionIntegrity]
  - The module executing this handler has a `ConnectionEnd` stored locally, (matching the input argument `local`) and in state `TRYOPEN`.

Postconditions:
  - the module executing this handler stores a `ConnectionEnd` (matching with the input argument `local`) in state `OPEN`
  - no output; may abort if preconditions not met

Implementation remarks:
  - (none)


##### Datagrams

A correct relayer can pushe the following datagrams at a chain.
Upon popping a datagram of a certain type, e.g., `ConnOpenConfirm`, a correct chain handles the datagram by invoking an eponymous handler.

```golang
type ConnOpenInit struct {
  local   ConnectionParty
  remote  ConnectionParty
}

type ConnOpenTry struct {
  local               ConnectionParty
  remote              ConnectionParty
  remoteVersions      string[]
  remoteStateProof    Proof
  remoteClientProof   Proof
}

type ConnOpenAck struct {
  local               ConnectionParty
  remoteVersion       string
  remoteStateProof    Proof
  remoteClientProof   Proof
}

type ConnOpenConfirm struct {
  local             ConnectionParty
  remoteStateProof  Proof
}
```

Notice that the fields in each datagram match with the corresponding protocol handler signature.

##### Relayer Logic

A correct relayer periodically scans a pair of chains and, if the chains are in a specific state (e.g., a connection is `INIT` on one of the chains and inexistent in the other chain), then the relayer performs the necessary steps in the CH protocol (e.g., construct the necessary `ConnOpenTry` datagram and pushes this datagram to the second chain).


###### Step 2.a:

```golang
// Assume `eAlice` is a connection on chain Alice.
if (eAlice.state == INIT) {
  // Handshake started at Alice (step 1 done because the connection is INIT).

  // Fetch the connection end from the other chain (Bob)
  eBob := chains[Bob].getConnection(eAlice.remote.connectionIdentifier)
  
  // We will do step 2.a, by pushing a `ConnOpenTry` to Bob.
  if (eBob == null || eBob.state == INIT) {
    // Construct the appropriate datagram.
    d := ConnOpenTry{
      eAlice.remote,                // Bob's end (a Party object)
      eAlice.local,                 // Alice's end
      eAlice.version,               // Alice's proposed version
      constructStateProof(eAlice),
      constructClientProof(eAlice)}

    // Push the datagram to Bob's module
    chains[Bob].push(d)
  }
}
```

###### Step 3.a:

```golang
// Assume `eBob` is a connection on chain Bob.
if (eBob.state == TRYOPEN) {
  // Fetch the matching connection end from Alice's side
  eAlice := chains[Alice].getConnection(eBob.remote.connectionIdentifier)
  
  // Handshake ConnOpenTry (step 2) done at Bob.
  // We will push a `ConnOpenAck` to Alice. This is step 3.a.
  if (eAlice.state == INIT || eAlice.state == TRYOPEN) {
    // Construct the appropriate datagram.
    d := ConnOpenAck{
      eBob.remote,                // Alice's party details
      eBob.version,               // Bob's proposed version
      constructStateProof(eBob),
      constructClientProof(eBob)}

    // Push the datagram to Bob's module
    chains[Alice].push(d)
  }
}
```

###### Step 4.a:

```golang
// Assume `eAlice` is a connection on chain Alice.
if (eAlice.state == OPEN) {
  // Fetch the matching connection end from Alice's side
  eBob := chains[Bob].getConnection(eAlice.remote.connectionIdentifier)
  
  // Handshake ConnOpenAck (step 3) done at Alice.
  // We will push a `ConnOpenConfirm` to Bob. This is step 4.a.
  if (eBob.state == TRYOPEN) {
    // Construct the appropriate datagram.
    d := ConnOpenAck{
      eBob.local,                 // Bob's party details
      constructStateProof(eAlice)}

    // Push the datagram to Bob's module
    chains[Bob].push(d)
  }
}
```

#### Helper functions & application-level predicates

###### `verifyProofs`

```golang
func verifyProofs(remoteStateProof Proof, 
                  remoteClientProof Proof,
                  connectionEnd ConnectionEnd)
  // Two syntactic check: for each proof, verify that it is authentic.
  // This return either true (success) or false (failure).
  // It is also acceptable that this function triggers an abort (e.g., due to
  // malformed input).
  t = verifyProofAuthenticity(remoteStateProof, connectionEnd)
  if t == false {
    return false
  }
  if remoteClientProof != nil {
    // This return either true (success) or false (failure). Aborting is also
    // acceptable.
    t = verifyProofAuthenticity(remoteClientProof, connectionEnd)
    if t == false {
      return false
    }
  }

  // Semantic checks of both proofs: interpret proof content and verify that
  // they make sense with respect to connection handshake protocol and our
  // state.
  // 1. Verify that the remote party has performed the 'INIT' step for this
  // specific connectionEnd. This helps guarantee the property
  // [CH/Proto/3/ConnectionIntegrity].
  // May trigger an abort if the verification fails. Usually returns true
  // or false.
  t = verifyRemoteState(remoteStateProof, ConnectionEnd)
  if t == false {
    return false
  }
  // 2. Verify that the client on the remote party is consistent with my state.
  // It seems that remoteStateProof is necessary for this step. This also
  // checks, among others, that remoteClientProof.height <= getCurrentHeight()
  // cf. [ICS 003].
  if remoteClientProof != nil {
    // May trigger an abort if the verification fails. Usually returns true
    // or false.
    t = verifyRemoteClient(
        remoteClientProof [,remoteStateProof], ConnectionEnd)
    if t == false {
      return false
    }
  }
  return true
```

Preconditions:
  - `remoteClientProof` may be nil
  - `remoteStateProof` and `connectionEnd` have to be well-former and non-nil

Postconditions:
  - returns true upon success, false if any verification failed.
  - if any of the preconditions are violated, the function may abort.
  - no side-effects.


###### `unique(ConnectionEnd c)`
This function takes as input a `ConnectionEnd` `c` and returns true if the input value `c` is unique.
Concretely, this verifies that there is no value stored in the local store at key `c.local.connectionIdentifier`, OR there is a value stored at this key and this value is identical with the supplied argument `c`.

###### `validate(ConnectionEnd c)` 
This checks that the object `connectionEnd.local.connectionIdentifier` is valid.
Similar in functionality with `validateConnectionIdentifier` from [ICS 003].

###### `pickVersion(counterpartyVersions)` 
This is identical with the one in [ICS 003](#references).

###### `getCompatibleVersions()`
This is identical with the one in [ICS 003](#references).


###### `constructStateProof()` and `constructClientProof()`

These are higher-level variants of the `proof()` method that a connection implements (see [ICS 018](#references) in particular).
TODO: This is a loose end. Should clarify here and in [ICS 018] how are proofs constructed.

### Open questions:

- Standard cryptographic assumptions (collision-resistant hash functions, public-key signatures). We should mention these once we have more details about the implementation.

- How to capture aborts or incorrect termination? See [issue raised by Anca](https://github.com/informalsystems/ibc-rs/pull/42#discussion_r397077901). Is this necessary? To inform this discussion, more implementation detials are neeeded.

- **Verification of the unbonding period** in `ConnOpenTry`. See [ICS/#403](https://github.com/cosmos/ics/issues/403).


## L3: Implementation

At this level, we "decapsulate" some of the abstractions we introduced at L2.
The goal is to strip away some of fields that may not be needed, and obtain function handlers that are identical with the ones specified in [ICS 003](#references).

The following list is of modification is non-exhaustive:

- Whenever we would use a `ConnectionParty` object, for instance, we would replace that object with the actual fields of the `ConnectionParty` that are needed (stripping off those fields that are unnecessary).
For example, instead of sending two `ConnectionParty` objects around, we send only the relevant fields.

Instead of:
```golang
func ConnOpenTry(a ConnectionParty, b ConnectionParty) {
```

in the actual code, we write:
```golang
func ConnOpenTry(
  desiredIdentifier: Identifier,
  counterpartyConnectionIdentifier: Identifier,
  counterpartyPrefix: CommitmentPrefix,
  counterpartyClientIdentifier: Identifier,
  clientIdentifier: Identifier,
  ...) {
```

- Whenever we use a `Proof` object, open up this abstraction and send both fields (i.e., `content` and `height`) as individual objects.

In other words, at this level of the spec, the protocol handlers become identical with those in [ICS 003](#references).
This decapsulation step essentially removes any abstractions that might be encumbering at the implementaiton level.


## References

- [ICS 003] Interchain Standards [ICS 003 Connection Semantics](https://github.com/cosmos/ics/tree/master/spec/ics-003-connection-semantics).
- [ICS 024] Interchain Standards [ICS 024 Host Requirements](https://github.com/cosmos/ics/tree/master/spec/ics-024-host-requirements).
- [ICS 018] Interchain Standards [ICS 024 Host Requirements](https://github.com/cosmos/ics/tree/master/spec/ics-018-relayer-algorithms).
- [IBC 1] Interchain Standards [IBC 1 Terminology](https://github.com/cosmos/ics/blob/master/ibc/1_IBC_TERMINOLOGY.md#actor).
- [IBC terminology] [IBC English terminology](https://github.com/cosmos/ics/blob/master/ibc/1_IBC_TERMINOLOGY.md)